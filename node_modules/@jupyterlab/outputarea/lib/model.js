// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
import * as nbformat from '@jupyterlab/nbformat';
import { ObservableList } from '@jupyterlab/observables';
import { OutputModel } from '@jupyterlab/rendermime';
import { map } from '@lumino/algorithm';
import { JSONExt } from '@lumino/coreutils';
import { Signal } from '@lumino/signaling';
/**
 * The default implementation of the IOutputAreaModel.
 */
export class OutputAreaModel {
    /**
     * Construct a new observable outputs instance.
     */
    constructor(options = {}) {
        /**
         * A flag that is set when we want to clear the output area
         * *after* the next addition to it.
         */
        this.clearNext = false;
        this._lastStreamName = '';
        this._trusted = false;
        this._isDisposed = false;
        this._stateChanged = new Signal(this);
        this._changed = new Signal(this);
        this._trusted = !!options.trusted;
        this.contentFactory =
            options.contentFactory || OutputAreaModel.defaultContentFactory;
        this.list = new ObservableList();
        if (options.values) {
            for (const value of options.values) {
                const index = this._add(value) - 1;
                const item = this.list.get(index);
                item.changed.connect(this._onGenericChange, this);
            }
        }
        this.list.changed.connect(this._onListChanged, this);
    }
    /**
     * A signal emitted when an item changes.
     */
    get stateChanged() {
        return this._stateChanged;
    }
    /**
     * A signal emitted when the list of items changes.
     */
    get changed() {
        return this._changed;
    }
    /**
     * Get the length of the items in the model.
     */
    get length() {
        return this.list ? this.list.length : 0;
    }
    /**
     * Get whether the model is trusted.
     */
    get trusted() {
        return this._trusted;
    }
    /**
     * Set whether the model is trusted.
     *
     * #### Notes
     * Changing the value will cause all of the models to re-set.
     */
    set trusted(value) {
        if (value === this._trusted) {
            return;
        }
        const trusted = (this._trusted = value);
        for (let i = 0; i < this.list.length; i++) {
            const oldItem = this.list.get(i);
            const value = oldItem.toJSON();
            const item = this._createItem({ value, trusted });
            this.list.set(i, item);
            oldItem.dispose();
        }
    }
    /**
     * Test whether the model is disposed.
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * Dispose of the resources used by the model.
     */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this._isDisposed = true;
        this.list.dispose();
        Signal.clearData(this);
    }
    /**
     * Get an item at the specified index.
     */
    get(index) {
        return this.list.get(index);
    }
    /**
     * Set the value at the specified index.
     */
    set(index, value) {
        value = JSONExt.deepCopy(value);
        // Normalize stream data.
        Private.normalize(value);
        const item = this._createItem({ value, trusted: this._trusted });
        this.list.set(index, item);
    }
    removeStreamOutput(number) {
        const prev = this.list.get(this.length - 1);
        const curText = prev.streamText;
        const length = curText.text.length;
        const options = { silent: true };
        curText.remove(length - number, length, options);
    }
    appendStreamOutput(text) {
        const prev = this.list.get(this.length - 1);
        const curText = prev.streamText;
        const length = curText.text.length;
        const options = { silent: true };
        curText.insert(length, text, options);
    }
    /**
     * Add an output, which may be combined with previous output.
     *
     * @returns The total number of outputs.
     *
     * #### Notes
     * The output bundle is copied.
     * Contiguous stream outputs of the same `name` are combined.
     */
    add(output) {
        // If we received a delayed clear message, then clear now.
        if (this.clearNext) {
            this.clear();
            this.clearNext = false;
        }
        return this._add(output);
    }
    /**
     * Remove an output at a given index.
     */
    remove(index) {
        var _a;
        (_a = this.list.remove(index)) === null || _a === void 0 ? void 0 : _a.dispose();
    }
    /**
     * Clear all of the output.
     *
     * @param wait Delay clearing the output until the next message is added.
     */
    clear(wait = false) {
        this._lastStreamName = '';
        if (wait) {
            this.clearNext = true;
            return;
        }
        for (const item of this.list) {
            item.dispose();
        }
        this.list.clear();
    }
    /**
     * Deserialize the model from JSON.
     *
     * #### Notes
     * This will clear any existing data.
     */
    fromJSON(values) {
        this.clear();
        for (const value of values) {
            this._add(value);
        }
    }
    /**
     * Serialize the model to JSON.
     */
    toJSON() {
        return Array.from(map(this.list, (output) => output.toJSON()));
    }
    /**
     * Add a copy of the item to the list.
     *
     * @returns The list length
     */
    _add(value) {
        const trusted = this._trusted;
        value = JSONExt.deepCopy(value);
        // Normalize the value.
        Private.normalize(value);
        // Consolidate outputs if they are stream outputs of the same kind.
        if (nbformat.isStream(value) &&
            value.name === this._lastStreamName &&
            this.length > 0 &&
            this.shouldCombine({
                value,
                lastModel: this.list.get(this.length - 1)
            })) {
            // We append the new text to the current text.
            // This creates a text change event.
            const prev = this.list.get(this.length - 1);
            const curText = prev.streamText;
            const newText = typeof value.text === 'string' ? value.text : value.text.join('');
            Private.addText(curText, newText);
            return this.length;
        }
        if (nbformat.isStream(value)) {
            if (typeof value.text !== 'string') {
                value.text = value.text.join('');
            }
            value.text = Private.processText(value.text);
        }
        // Create the new item.
        const item = this._createItem({ value, trusted });
        // Add the item to our list and return the new length.
        const length = this.list.push(item);
        // Update the stream information.
        if (nbformat.isStream(value)) {
            this._lastStreamName = value.name;
        }
        else {
            this._lastStreamName = '';
        }
        return length;
    }
    /**
     * Whether a new value should be consolidated with the previous output.
     *
     * This will only be called if the minimal criteria of both being stream
     * messages of the same type.
     */
    shouldCombine(options) {
        return true;
    }
    /**
     * Create an output item and hook up its signals.
     */
    _createItem(options) {
        const factory = this.contentFactory;
        const item = factory.createOutputModel(options);
        return item;
    }
    /**
     * Handle a change to the list.
     */
    _onListChanged(sender, args) {
        switch (args.type) {
            case 'add':
                args.newValues.forEach(item => {
                    item.changed.connect(this._onGenericChange, this);
                });
                break;
            case 'remove':
                args.oldValues.forEach(item => {
                    item.changed.disconnect(this._onGenericChange, this);
                });
                break;
            case 'set':
                args.newValues.forEach(item => {
                    item.changed.connect(this._onGenericChange, this);
                });
                args.oldValues.forEach(item => {
                    item.changed.disconnect(this._onGenericChange, this);
                });
                break;
        }
        this._changed.emit(args);
    }
    /**
     * Handle a change to an item.
     */
    _onGenericChange(itemModel) {
        let idx;
        let item = null;
        for (idx = 0; idx < this.list.length; idx++) {
            item = this.list.get(idx);
            if (item === itemModel) {
                break;
            }
        }
        if (item != null) {
            this._stateChanged.emit(idx);
            this._changed.emit({
                type: 'set',
                newIndex: idx,
                oldIndex: idx,
                oldValues: [item],
                newValues: [item]
            });
        }
    }
}
/**
 * The namespace for OutputAreaModel class statics.
 */
(function (OutputAreaModel) {
    /**
     * The default implementation of a `IModelOutputFactory`.
     */
    class ContentFactory {
        /**
         * Create an output model.
         */
        createOutputModel(options) {
            return new OutputModel(options);
        }
    }
    OutputAreaModel.ContentFactory = ContentFactory;
    /**
     * The default output model factory.
     */
    OutputAreaModel.defaultContentFactory = new ContentFactory();
})(OutputAreaModel || (OutputAreaModel = {}));
/**
 * A namespace for module-private functionality.
 */
var Private;
(function (Private) {
    /**
     * Normalize an output.
     */
    function normalize(value) {
        if (nbformat.isStream(value)) {
            if (Array.isArray(value.text)) {
                value.text = value.text.join('\n');
            }
        }
    }
    Private.normalize = normalize;
    /**
     * Like `indexOf` but allowing to use a regular expression.
     */
    function indexOfAny(text, re, i) {
        const index = text.slice(i).search(re);
        return index >= 0 ? index + i : index;
    }
    /*
     * Handle backspaces in `newText` and concatenates to `text`, if any.
     */
    function processText(newText, text) {
        if (text === undefined) {
            text = '';
        }
        if (!(newText.includes('\b') || newText.includes('\r'))) {
            return text + newText;
        }
        let idx0 = text.length;
        let idx1 = -1;
        let lastEnd = 0;
        const regex = /[\n\b\r]/;
        // TODO: once we upgrade eslint to 9.1.0 we can toggle `allExceptWhileTrue`
        // option and remove the ignore rule below.
        // eslint-disable-next-line no-constant-condition
        while (true) {
            idx1 = indexOfAny(newText, regex, lastEnd);
            // Insert characters at current position.
            const prefix = newText.slice(lastEnd, idx1 === -1 ? newText.length : idx1);
            text = text.slice(0, idx0) + prefix + text.slice(idx0 + prefix.length);
            lastEnd = idx1 + 1;
            if (idx1 === -1) {
                break;
            }
            idx0 += prefix.length;
            const newChar = newText[idx1];
            if (newChar === '\b') {
                // Backspace: delete previous character if there is one and if it's not a line feed.
                if (idx0 > 0 && text[idx0 - 1] !== '\n') {
                    text = text.slice(0, idx0 - 1) + text.slice(idx0 + 1);
                    idx0--;
                }
            }
            else if (newChar === '\r') {
                // Carriage return: go back to beginning of line.
                let done = false;
                while (!done) {
                    if (idx0 === 0) {
                        done = true;
                    }
                    else if (text[idx0 - 1] === '\n') {
                        done = true;
                    }
                    else {
                        idx0--;
                    }
                }
            }
            else if (newChar === '\n') {
                // Insert new line at end of text.
                text = text + '\n';
                idx0 = text.length;
            }
            else {
                throw Error(`This should not happen`);
            }
        }
        return text;
    }
    Private.processText = processText;
    /*
     * Concatenate a string to an observable string, handling backspaces.
     */
    function addText(curText, newText) {
        const text = processText(newText, curText.text);
        // Compute the difference between current text and new text.
        let done = false;
        let idx = 0;
        while (!done) {
            if (idx === text.length) {
                if (idx === curText.text.length) {
                    done = true;
                }
                else {
                    curText.remove(idx, curText.text.length);
                    done = true;
                }
            }
            else if (idx === curText.text.length) {
                if (idx !== text.length) {
                    curText.insert(curText.text.length, text.slice(idx));
                    done = true;
                }
            }
            else if (text[idx] !== curText.text[idx]) {
                curText.remove(idx, curText.text.length);
                curText.insert(idx, text.slice(idx));
                done = true;
            }
            else {
                idx++;
            }
        }
    }
    Private.addText = addText;
})(Private || (Private = {}));
//# sourceMappingURL=model.js.map